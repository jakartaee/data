// Copyright (c) 2022,2024 Contributors to the Eclipse Foundation
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0

== Repository

In the realm of software design, the repository pattern encapsulates the logic required to access data sources. This pattern consolidates data access functionality, offering improved maintainability and decoupling the infrastructure or technology used to access databases from the domain model layer.

image::01-repository.png[alt=repository structure, width=70%, height=70%]

The Repository pattern is a fundamental concept within Jakarta Data that plays a central role in data access and management. Essentially, a repository is a mediator between an application's domain logic and the underlying data storage, be it a relational database, NoSQL database, or any other data source.

In Jakarta Data, a Repository provides a structured and organized way to interact with data. It abstracts data storage and retrieval complexities, allowing you to work with domain-specific objects and perform common operations on data without writing low-level database queries.

As employed in Jakarta Data, the Repository pattern exhibits several key characteristics that make it a powerful tool for managing data access within Java applications. These characteristics collectively define how repositories function within Jakarta Data, providing a structured and domain-centric approach to working with data. These key characteristics offer insight into how repositories simplify data access and enhance the maintainability of code.

- **Abstraction:** Repositories abstract the details of how data is stored, enabling the developer to focus on the application's domain logic without being tightly coupled to a specific database technology.

- **Structured Data Access:** Jakarta Data repositories offer a structured and consistent way to perform data access operations. This structured approach ensures that the codebase remains organized and maintainable.

- **Domain-Centric:** Repositories are designed to be domain-centric, aligning with the application's domain model. It means that data access operations are closely tied to business entities, making code more intuitive and expressive.

In summary, the Repository pattern in Jakarta Data offers a structured and domain-centric approach to data access, providing a balance between abstraction and ease of use. It simplifies data access by encapsulating the details of the data source while aligning closely with the application's domain model. It makes it a valuable choice for many Java developers, especially in projects where a clean separation of concerns and maintainable codebase are essential.

=== Repositories in Jakarta Data

Within the context of Jakarta Data, the repository plays a pivotal role in simplifying data access for various persistence stores. The repository is a Java interface that acts as a gateway for accessing persistent data of one or more entity types. Repositories offer a streamlined approach to working with data by exposing operations for querying, retrieving, and modifying entity class instances that represent data in the persistent store.

Several characteristics define repositories:

- **Reduced Boilerplate Code:** One of the primary goals of a repository abstraction is to significantly reduce the boilerplate code required to implement data access layers for diverse persistence stores. This reduction in repetitive code enhances code maintainability and developer productivity.

- **Jakarta Data Annotations:** In Jakarta Data, repositories are defined as interfaces and are annotated with the `@Repository` annotation. This annotation serves as a marker to indicate that the interface represents a repository.

- **Built-In Interfaces:** The Jakarta Data specification provides a set of built-in interfaces from which repositories can inherit. These built-in interfaces offer a convenient way to include a variety of pre-defined methods for common operations. They also declare the entity type to use for methods where the entity type cannot otherwise be inferred.

- **Data Retrieval and Modification:** Repositories facilitate data retrieval and modification operations. This includes querying for persistent instances in the data store, creating new persistent instances in the data store, removing existing persistent instances, and modifying the state of persistent instances. Conventionally, these operations are named insert, update, save and delete for modifying operations and find, count, and exists for retrieval operations.

- **Subset of Data:** Repositories may expose only a subset of the full data set available in the data store, providing a focused and controlled access point to the data.

- **Entity Associations:** Entities within a repository may have associations between them, especially in the case of relational data access. However, this specification does not define the semantics of associations between entities belonging to different repositories.

- **Stateless Repositories:** Repositories are stateless. This specification does not address the definition of repositories that externalize Jakarta Persistence-style stateful persistence contexts.

Repositories in Jakarta Data serve as efficient gateways for managing and interacting with persistent data, offering a simplified and consistent approach to data access and modification within Java applications.

The application must provide the following when using repositories in Jakarta Data:

1. **Entity Classes and Mappings:** Developers define a set of entity classes and mappings tailored to a specific data store. These entities represent the data structure and schema, offering a powerful means to interact with the underlying data.

2. **Repository Interfaces:** Jakarta Data enables the creation of one or more repository interfaces, following predefined rules that include the guidelines set forth by this specification. These interfaces are the gateways to accessing and manipulating the data, offering a structured and efficient way to perform data operations.

An implementation of Jakarta Data, specifically tailored to the chosen data store, assumes the responsibility of implementing each repository interface. This symbiotic relationship between developers and Jakarta Data ensures that data access and manipulation remain consistent, efficient, and aligned with best practices.

Jakarta Data empowers developers to shape their data access strategies by defining entity classes and repositories, with implementations seamlessly adapting to the chosen data store. This flexibility and Jakarta Data's persistence-agnostic approach promote robust data management within Java applications.

The Jakarta Data specification supports two basic ways to define a repository interface:

- by extending one of the generic repository supertype interfaces defined by Jakarta Data, or
- by annotating the methods of an interface which does _not_ extend any built-in supertype.

A Java developer creates an interface, marks it with the `@Repository` annotation, and has the option to extend one or more built-in generic repository interfaces, or to annotate its lifecycle methods.

NOTE: Jakarta Data allows applications to intermix the two approaches by defining methods annotated with `@Insert`, `@Update`, `@Delete`, or `@Save` on repositories which inherit the built-in supertypes.

==== Repositories with Built-in Supertypes

Jakarta Data defines a hierarchy of built-in interfaces which user-defined repositories may inherit. At the root of this hierarchy is the `DataRepository` interface. A repository is permitted to extend one or more of the members of the hierarchy, or none at all. When a repository extends a built-in interface, the implementation of every method inherited from the built-in interface must preserve the semantics specified by the built-in interface.

[ditaa]
....
                          +----------------+
                          | DataRepository |
                          +----------------+
                                  ^
                                  |
                                  |
                          +-----------------+
                          | BasicRepository |
                          +-----------------+
                                  ^
                                  |
                                  |
                        +--------------------+
                        | CrudRepository     |
                        +--------------------+

....

A repository which extends a built-in supertype usually acts as a home for operations acting in a single entity type.
This entity type is designated via the first generic type variable of the generic supertype.

- The `BasicRepository` interface includes some of the most common operations applying to a single type of entity, including `save()`, `delete()`, and `findById()`.

- The `CrudRepository` interface inherits `BasicRepository`, adding `insert()` and `update()` methods corresponding to the Create and Update operations of the CRUD (Create, Read, Update, Delete) pattern.

Given a `Product` entity with ID of type `long`, the repository could be as simple as:

[source,java]
----
@Repository
public interface ProductRepository extends BasicRepository<Product, Long> {

}
----


There is no nomenclature restriction requiring the `Repository` suffix. For example, a repository for the `Car` entity does not need to be named `CarRepository`. It could be named `Cars`, `Vehicles`, or even `Garage`.

[source,java]
----
@Repository
public interface Garage extends BasicRepository<Car, String> {

}
----

==== Repositories without Built-in Supertypes

Alternatively, Jakarta Data allows a custom repository interface which does not extend any built-in type. This option:

- provides the developer with complete control over the operations available, and over their naming, and
- allows a single repository to declare operations acting on a family of related entities, instead of being limited to just one entity type.

In this approach, database operations involving fundamental data changes, such as insertion, update, and removal, are realized via the use of lifecycle annotations like `@Insert`, `@Update`, `@Delete`, and `@Save`. These annotations enable the crafting of expressive and contextually meaningful repository methods, resulting in a repository API that closely mirrors the semantics of the domain.

For instance, consider the `Garage` repository interface below:

[source,java]
----
@Repository
public interface Garage {

    @Insert
    Car park(Car car);

    @Delete
    void unpark(Car car);
}
----

Notice that the `@Insert` annotation is used to declare the `park()` method.

The previous example illustrates the design of a repository interface which captures some of the essence of the business domain. This approach fosters a shared understanding and more intuitive communication within the development team, with database operations named according to the language of the domain.

== Entity Classes

The notion of an _entity_ is the fundamental building block with which a data model may be constructed.
Abstractly, an entity (or _entity type_) is a schema for data.

- The schema may be as simple as a tuple of types, as is typical in the relational model, or it might be structured, as in document data stores.
- The schema might be explicit, as in the case of SQL DDL declaring a relational table, or it might be implicit, as is commonplace in key/value stores.
- Either way, we assume that the entity is represented in Java as a class, which we call the _entity class_. footnote:[We will not consider generic programs which work with entity data via detyped representations.]

NOTE: When there's no risk of confusion, we often use the word “entity” to mean the entity class, or even an instance of the entity class.

Data represented by an entity is persistent, that is, the data itself outlives any Java process which makes use of it. Thus, it is necessary to maintain an association between instances of Java entity classes and state held in a data store.

- Each persistent instantiation of the schema is distinguishable by a unique _identifier_. For example, a row of a relational database table is identifiable by the value of its primary key.
- Any persistent instantiation of the schema is representable by an instance of the entity class. In a given Java program, multiple entity class instances might represent the same persistent instance of the schema.

In Jakarta Data, the concrete definition of an entity may be understood to encompass the following aspects:

1. The *entity class* itself: An entity class is simple Java object equipped with fields or accessor methods designating each property of the entity. An entity class is identified by an annotation.

2. Its *data schema*: Some data storage technologies require an explicit schema defining the structure and properties of the data the entity represents. For example, a relational database requires that the schema be specified using SQL Data Definition Language (DDL) statements. The schema might be generated by the Jakarta Data provider, from the information available in the Java entity class, or it might be managed independently. When the data store itself does not require an explicit schema, the data schema is implicit.

3. Its *association with a repository*: Each entity class is associated with at least one repository, which exposes operations for retrieving and storing instances of the entity.

NOTE: A Jakarta Data provider might allow the state of a single Jakarta Data entity to be stored across multiple entities in the data store. For example, in Jakarta Persistence, the `@SecondaryTable` annotation allows the state of an entity to be mapped across more than one database table.

=== Programming Model for Entity Classes

A _programming model for entity classes_ specifies:

- a set of restrictions on the implementation of a Java class which allows it to be used as an entity class with a given Jakarta Data provider, and
- a set of annotations allowing the identification of a Java class as an entity class, and further specification of the schema of the entity.

Jakarta Data does not define its own programming model for entities, but instead:

- is compatible with the programming models defined by the Jakarta Persistence and Jakarta NoSQL specifications, and
- allows for vendor-specific entity programming models to be defined by Jakarta Data providers.

This section lays out the core requirements that an entity programming model must satisfy in order to be compatible with Jakarta Data, and for the defining provider to be considered a fully-compliant implementation of this specification.

Every entity programming model specifies an _entity-defining annotation_. For Jakarta Persistence, this is `jakarta.persistence.Entity`. For Jakarta NoSQL, it is `jakarta.nosql.Entity`. A Jakarta Data provider must provide repository implementations for entity classes bearing the entity-defining annotations it supports, and must ignore entity classes with entity-defining annotations it does not support.

NOTE: To maintain clarity and to disambiguate the desired Jakarta Data provider, a single entity class should not mix entity-defining annotations from different providers. For example, an entity class should not be annotated both `jakarta.persistence.Entity` and `jakarta.nosql.Entity`. This practice allows the entity-defining annotation to indicate the desired provider in programs where multiple Jakarta Data providers are available.

Furthermore, an entity programming model must define an annotation which identifies the field or property holding the unique identifier of an entity. For Jakarta Persistence, it is `jakarta.persistence.Id` or `jakarta.persistence.EmbeddedId`. For Jakarta NoSQL, it is `jakarta.nosql.Id`. Alternatively, an entity programming model might allow the identifier field or property to be identified via some convention.

Typically, an entity programming model specifies additional annotations which are used to make the schema of the entity explicit, for example, `jakarta.persistence.Id` and `jakarta.persistence.Column`, or `jakarta.nosql.Id` and `jakarta.nosql.Column`. The nature of such annotations is beyond the scope of this specification.

In a given entity programming model, entity classes might always be mutable, or might always be immutable, or, alternatively, the model might support a mix of mutable and immutable entity classes.

- A programming model which supports immutable entity classes may require that every mutable entity class declare a constructor with no parameters, and might place limits on the visibility of this constructor.
- A programming model which supports the use of immutable entity classes--ideally represented as Java `record` types--would not typically require the existence of such a constructor.

In either case, an entity programming model might place restrictions on the visibility of fields and property accessors of an entity class.

==== Entity Inheritance

An entity programming model might support inheritance between entities.
Two entities are related by inheritance if:

1. the entity classes are related by Java language inheritance, and
2. the Jakarta Data provider supports retrieving and querying the entities in a polymorphic fashion.

It's possible for two entity classes to be related by Java inheritance, but _not_ by entity inheritance in the sense defined here.
An entity programming model specifies which Java inheritance relationships are interpreted as entity inheritance.

When entities are related by inheritance, a query method which returns the entity supertype might also return instances of its subtypes.

The Jakarta Data provider determines how entity classes which participate in an entity inheritance hierarchy "map" to the data schema.
For example, in a relational datastore, all entities in the hierarchy might be stored together on one table, or each entity might have its own dedicated table.

Support for entity inheritance is not required by this specification.

==== Persistent Fields

A field of an entity class may or may not represent state which is persistent in the datastore.
A _persistent field_ has some corresponding representation in the data schema of the entity, for example, it might map to a column or columns in a relational database table.
Any programming model for entity classes must provide well-defined rules for distinguishing fields which are persistent in the datastore from which fields are _transient_, having no persistent representation in the datastore.
Furthermore, the programming model must specify how the Jakarta Data provider accesses the persistent fields of an entity to read and write their values.

Every programming model for entity classes must support _direct field access_, that is, access to the persistent fields of an entity class without triggering any intermediating user-written code such as JavaBeans-style property accessors.
When direct field access is used, every Java field marked with the Java language `transient` modifier must be treated as transient.
A programming model might place constraints on the visibility of persistent fields.
For example, Jakarta Persistence disallows `public` persistent fields.
Every programming model must permit `private` persistent fields.

A programming model for entity classes might also support _property-based access_, that is, access to persistent fields via JavaBeans-style property accessors, or, especially for Java `record` types, via accessor methods combined with constructor-based initialization.
Such programming models should provide an annotation or other convention to distinguish transient properties.
For example, Jakarta Persistence provides `jakarta.persistence.Transient`.
When property-based access is supported, a programming model might place constraints on the visibility of property accessors.
For example, Jakarta Persistence requires that property accessors be `public` or `protected`.
Support for property-based access is not required by this specification.

Jakarta Data distinguishes three kinds of persistent field within entity classes.

- A _basic field_ holds a value belonging to some fundamental data type supported natively by the Jakarta Data Provider. Support for the set of basic types enumerated in the next section below is mandatory for all Jakarta Data providers.
- An _embedded field_ allows the inclusion of the state of a finer-grained Java class within the state of an entity. The type of an embedded field is often a user-written Java class. Support for embedded fields varies depending on the Jakarta Data provider and the database type.
- An _association field_ implements an association between entity types. Support for association fields varies depending on the Jakarta Data provider and the database type.

==== Basic Types

Every Jakarta Data provider must support the following basic types within its programming model:

|===
| Basic Data Type | Description

| Primitive types and wrapper classes
| All Java primitive types, such as `int`, `double`, `boolean`, etc., and their corresponding wrapper types from `java.lang` (e.g., `Integer`, `Double`, `Boolean`).

| `java.lang.String`
| Represents text data.

| `LocalDate`, `LocalDateTime`, `LocalTime`, `Instant` from `java.time`
| Represent date and time-related data.

| `java.util.UUID`
| Universally Unique IDentifier for identifying entities.

| `BigInteger` and `BigDecimal` from `java.math`
| Represent large integer and decimal numbers.

| `byte[]`
| Represents binary data.

| User-defined `enum` types
| Custom enumerated types defined by user-written code.
|===

For example, the following entity class has five basic fields:

[source,java]
----
@Entity
public class Person {
    @Id
    private UUID id;
    private String name;
    private long ssn;
    private LocalDate birthdate;
    private byte[] photo;
}
----

In addition to the types listed above, an entity programming model might support additional domain-specific basic types. This extended set of basic types might include types with a nontrivial internal structure. An entity programming model might even provide mechanisms to convert between user-written types and natively-supported basic types. For example, Jakarta Persistence defines the `AttributeConverter` interface.

NOTE: Many key-value, wide-column, document, and relational databases feature native support for arrays or even associative arrays of these basic types. Unfortunately, the semantics of such types--along with their performance characteristics--are extremely nonuniform, and so support for such types is left undefined by the Jakarta Data specification.

==== Embedded Fields and Embeddable Classes

An _embeddable class_ differs from an entity class in that:

- the embeddable class lacks its own persistent identity, and
- the state of an instance of the embeddable class can only be stored in the database when the instance is referenced directly or indirectly by a "parent" entity class instance.

An _embedded field_ is a field whose type is an embeddable class.

Like entities, embeddable classes may have basic fields, embeddable fields, and association fields, but, unlike entities, they do not have identifier fields.

Like entities, a programming model for entity classes might support mutable embeddable classes, immutable embeddable classes, or both.

A programming model for entity classes might define an annotation that identifies a user-written class as an embeddable class. For example, Jakarta Persistence defines the annotation `jakarta.persistence.Embeddabe`. Alternatively, the programming model might define an annotation that identifies a field as an embedded field. For example, Jakarta Persistence defines the annotation `jakarta.persistence.Embedded`.

There are two natural ways that a Jakarta Data provider might store the state of an instance of an embedded class in a database:

- by _flattening_ the fields of the embeddable class into the data structure representing the parent entity, or
- by _grouping_ the fields of the embedded class into a fine-grained structured type (a UDT, for example).

In a flattened representation of an embedded field, the fields of the embeddable class occur directly alongside the basic fields of the entity class in the data schema of the entity.
There is no representation of the embeddable class itself in the data schema.

For example, consider the following Java classes:

[source,java]
----
@Embeddable
public class Address {
    private String street;
    private String city;
    private String postalCode;
}

@Entity
public class Person {
    @Id
    private Long id;
    private String name;
    private Address address;  // embedded field
}
----

In a document, wide-column, or graph database, the JSON representation of an instance of the `Person` entity might be as follows:

[source,json]
----
{
  "id": 1,
  "name": "John Doe",
  "street": "123 Main St",
  "city": "Sampleville",
  "postalCode": "12345"
}
----

Or, in a relational database, the DDL for the `Person` table might look like this:

[source,sql]
----
create table Person (
    id bigint primary key,
    name varchar,
    street varchar,
    city varchar,
    postalCode varchar
)
----

In a structured representation, the fields of the embeddable class are somehow grouped together in the data schema.

For example, the JSON representation of `Person` might be:

[source,json]
----
{
  "id": 1,
  "name": "John Doe",
  "address":
  {
    "street": "123 Main St",
    "city": "Sampleville",
    "postalCode": "12345"
  }
}
----

Or the SQL DDL could be:

[source,sql]
----
create type Address as (
    street varchar,
    city varchar,
    postalCode varchar
)

create table Person (
    id bigint primary key,
    name varchar,
    address Address
)
----

NOTE: Support for embeddable classes and embedded fields is not required by this specification.
However, every Jakarta Data provider is strongly encouraged to provide support for embeddable classes within its entity programming model.

==== Entity Associations

An association field is a field of an entity class whose declared type is also an entity class.
Given an instance of the first entity class, its association field holds a reference to an instance of a second entity class.

For example, consider the following Java classes:

[source,java]
----
@Entity
public class Author {
    @Id
    private UUID id;
    private String name;
    private List<Book> books;
}

@Entity
public class Book {
    @Id
    private Long id;
    private String title;
    private String category;
    private List<Author> authors;
}
----

In a relational database, these entities might map to the following data schema:

[source,sql]
----
create table Author (
    uuid id primary key,
    name varchar,
)

create table BookAuthor(
    book bigint,
    author uuid,
    primary key (book, author),
    foreign key (author) references Author,
    foreign key (book) references Book
)

create table Book (
    id bigint primary key,
    title varchar,
    category varchar
)
----

NOTE: Support for entity associations is not required by this specification.

==== Entity Names

Each entity must be assigned an _entity name_ by the provider.
By default, this must be the unqualified Java class name of the entity class.
A programming model for entity classes might provide a way to explicitly specify an entity name.
For example, Jakarta Persistence allows the entity name to be specified via the `name` member of the `@Entity` annotation.

==== Persistent Field Names

Each persistent field of an entity, as defined above in <<Persistent Fields>>, or of an embeddable class, as defined in <<Embedded Fields and Embeddable Classes>>, must be assigned a name, allowing the persistent field to be referenced by an <<Parameter-based automatic query methods,automatic query method>>, a <<Query by Method Name>>, or from a query specified within the <<Annotated Query methods,`@Query` annotation>>.

- when direct field access is used, the name of a persistent field is simply the name of the Java field, but
- when property-based access is used, the name of the field is derived from the accessor methods.

Any programming model for entity classes which supports property-based access must also define a rule for assigning names to persistent fields. Typically, a property with accessors named `getX` and `setX` is assigned a persistent field name obtained by calling `java.beans.Introspector.decapitalize("X")`.

Within a given entity class or embeddable class, names assigned to persistent fields must be unique ignoring case. A Jakarta Data provider is permitted to reject an entity class if two persistent fields would be assigned the same name.

Furthermore, within the context of a given entity, each persistent field of an embeddable class reachable by navigation from the entity class may be assigned a compound name. The compound name is obtained by concatenating the names assigned to each field traversed by navigation from the entity class to the persistent field of the embedded class, optionally joined by a delimiter.

The rule for concatenating compound names depends on the context, and is specified in <<property-name-concatenation>>. The examples in the table assume an `Order` entity has an `address` of type `MailingAddress` with a `zipCode` of type `int`.

[[property-name-concatenation]]
.Field Name Concatenation and Delimiters
[cols="3, 2, ^1, 6"]
|===
| Context | Type | Delimiter | Example

| `@Find` | Parameter name
|`_`
|`@Find List<Order> find(int address_zipCode);`

|`@Query` | Path expression within query
|`.`
|`@Query("SELECT o FROM Order o WHERE o.address.zipCode=?1")`

|_Query by Method Name_ | Method name
|`_`
|`List<Order> findByAddress_zipCode(int zip);`

|`Sort` | String argument
|`.` or `_`
|`Sort.asc("address_zipCode")`

|`@By` or `@OrderBy` | Annotation value
|`.` or `_`
|`@Find List<Order> find(@By("address.zipCode") int zip);`
|===

NOTE: Application programmers are strongly encouraged to follow Java's camel case naming standard for fields of entities, relations, and embeddable classes, avoiding underscores in field names. The resolution algorithm for persistent field identification relies on the use of underscore as a delimiter. Adhering to the camel case naming convention ensures consistency and eliminates ambiguity.


==== Persistent Field Names in Query by Method Name

For _Query by Method Name_, the use of delimiters within a compound name is optional. Delimiters may be omitted entirely from a compound name when they are not needed to disambiguate the persistent field to which the name refers. But for a given entity property name, delimiter usage must be consistent: either the delimiter must be used between every pair of persistent field names within the compound name, or it must not occur within the compound name.

Resolution of a persistent field involves the following steps:

1. A persistent field name is extracted from the method name according to the <<BNF Grammar for Query Methods>>. For example, if the query method name is `findByAddressZipCode`, the extracted field name is `AddressZipCode`.

2. The extracted name is matched against the fields of the entity class. If the name assigned to a persistent field of the entity class matches the extracted name, ignoring case, then the extracted name resolves to that field.

3. Otherwise, if no match is found among the fields of the entity, the extracted name is matched against the fields of entity classes and embedded classes reachable from the entity class, interpreting the extracted name as a compound name, as outlined in the previous section, both with and without the optional delimiter. If the compound name assigned to a persistent field matches the extracted name, also interpreted as a compound name, and ignoring case, then the extracted name resolves to that field.

4. If no matching persistent field is found in either of the previous steps, the provider is permitted to reject the query method or to throw `UnsupportedOperationException` when the method is called.

A persistent field name used in a _Query by Method Name_ must not contain a <<Query by Method Name Keywords,keyword>> reserved by _Query by Method Name_.


===== Scenario 1: Person Repository with Unambiguous Resolution

In this scenario, we have the following data model:

[source,java]
----
class Person {
  private Long id;
  private MailingAddress address;
}

class MailingAddress {
  private int zipcode;
}
----

The `Person` entity does not have an `addressZipCode` field, so use of the delimiter is optional. It is valid to write both of the following repository methods, which have the same meaning,

[source,java]
----
List<Person> findByAddressZipCode(int zipCode);
List<Person> findByAddress_zipcode(int zipCode);
----

===== Scenario 2: Order Repository with Resolution that requires a Delimiter

In this scenario, we have the following data model:

[source,java]
----
class Order {
  private Long id;
  private String addressZipCode;
  private MailingAddress address;
}

class MailingAddress {
  private int zipcode;
}
----

The `Order` entity has an `addressZipCode` field, as well as an `address` field for an embeddable class with a `zipcode` field. The method name `findByAddressZipCode` points to the `addressZipCode` field and cannot be used to navigate to the embedded class. To navigate to the `zipcode` field of the embedded class, the delimiter must be used:

[source,java]
----
List<Order> findByAddress_zipcode(int zipCode);
----


==== Type-safe Access to Entity Attributes

Jakarta Data provides a static metamodel that allows entity attributes to be accessed by applications in a type-safe manner.

For each entity class, the application developer or a compile-time annotation processor can define a corresponding metamodel class following a prescribed set of conventions. The metamodel class must be annotated with `@StaticMetamodel`, specifying the entity class as its `value`. The metamodel class can contain one or more fields of type `java.lang.String` or `jakarta.data.metamodel.Attribute` (or `Attribute` subclasses from the `jakarta.data.metamodel` package) with modifiers `public` and `static`, but not `final`, with each field named after an entity attribute. The value of each matching field can be left uninitialized (`null`) or can be preinitialized. Generated metamodel classes for which all fields are initialized must be annotated with the `jakarta.annotation.Generated` annotation. Otherwise, a Jakarta Data provider that provides a repository for the entity class initializes each uninitialized `String` and `Attribute` field (as well as fields for `Attribute` subclasses from the `jakarta.data.metamodel` package) for which the field name corresponds to an entity attribute name.

===== Application Requirements for a Metamodel Class

For each entity class for which the application wishes to request the metamodel,

- The application defines a class (the metamodel class) and annotates it with the `@StaticMetamodel` annotation.
- The application specifies the `value` of the `@StaticMetamodel` annotation to be an entity class that the application uses in a repository as the result type of a find method or the parameter type of an insert, update, save, or delete method.

For each field of the metamodel class that is to be initialized by a Jakarta Data provider,

- The field type must be `java.lang.String`, `jakarta.data.model.Attribute` or an `Attribute` subclass from the `jakarta.data.metamodel` package.
- The field must have the `public` and `static` modifiers, but not the `final` modifier.
- The name of the field, ignoring case, must match the name of an entity attribute, with the `_` character in the field name delimiting the attribute names of hierarchical structures or relationships, such as embedded classes.
- The value of the field must be uninitialized or `null`.

The application is not required to include fields for all entity attributes.

The application can use the field values of the metamodel class to obtain artifacts relating to the entity attribute in a type-safe manner, for example, `_Book.title.asc()` or `Sort.asc(_Book.title.name())` or `Sort.asc(_Book.TITLE)` rather than `Sort.asc("title")`.

If the application defines repositories for the same entity class across multiple Jakarta Data providers, no guarantee is made of the order in which the fields of the metamodel class are assigned by the Jakarta Data providers.

===== Compile-time Annotation Processor Requirements for a Metamodel Class

A compile-time annotation processor that generates a metamodel class must follow the same requirements as stated for the Application under "Application Requirements for a Metamodel Class". If all fields of the metamodel class are preinitialized, then the metamodel class must be annotated with `jakarta.annotation.Generated`. This signals the Jakarta Data providers to avoid attempting to initialize any fields of the class.

===== Jakarta Data Provider Requirements for a Metamodel Class

The Jakarta Data provider observes classes that are annotated with the `@StaticMetamodel` annotation where the `jakarta.annotation.Generated` is not also present. If the `value` of the `@StaticMetamodel` annotation is an entity class for which the Jakarta Data provides a repository implementation, then the Jakarta Data provider must initialize the value of each uninitialized (`null` valued) field that meets the criteria that is defined in the "Application Requirements for a Metamodel Class" above.

===== Conventions for Metamodel Fields

The following are conventions for static metamodel classes:

- The name of the static metamodel class should consist of underscore (`_`) followed by the entity class name.
- Fields of type `String` should be named with all capitals.
- Fields of type `Attribute` or `Attribute` subclass should be named in lower case or mixed case.
- Uninitialized fields should have modifiers `public`, `static`, and `volatile`.
- `String` fields for entity attribute names should be preinitialized and have modifiers `public`, `static`, and `final`, enabling the field to be referenced by code that supplies values to annotations.

===== Example Metamodel Class and Usage

Example entity class:

[source,java]
----
@Entity
public class Product {
  public long id;
  public String name;
  public float price;
}
----

Example metamodel class for the entity:

[source,java]
----
@StaticMetamodel(Product.class)
public class _Product {
  public static final String ID = "id";
  public static final String NAME = "name";
  public static final String PRICE = "price";

  public static volatile SortableAttribute<Product> id;
  public static volatile TextAttribute<Product> name;
  public static volatile SortableAttribute<Product> price;
}
----

Example usage:

[source,java]
----
List<Product> found = products.findByNameLike(searchPattern,
                                              _Product.price.desc(),
                                              _Product.name.asc(),
                                              _Product.id.asc());
----


== Repository Interfaces

A Jakarta Data repository is a Java interface annotated with `@Repository`.
A repository interface may declare:

- _abstract_ (non-`default`) methods, and
- _concrete_ (`default`) methods.

A concrete method may call other methods of the repository, including abstract methods.

Every abstract method of the interface is usually either:

- an entity instance _lifecycle method_,
- an _annotated query method_,
- an _automatic query method_ (with parameter-based conditions or Query by Method Name), or
- a _resource accessor method_.

A repository may declare lifecycle methods for a single entity type, or for multiple related entity types.
Similarly, a repository might have query methods which return different entity types.

A repository interface may inherit methods from a superinterface.
A Jakarta Data implementation must treat inherited abstract methods as if they were directly declared by the repository interface.
For example, a repository interface may inherit the `CrudRepository` interface defined by this specification.

Repositories perform operations on entities. For repository methods that are annotated with `@Insert`, `@Update`, `@Save`, or `@Delete`, the entity type is determined from the method parameter type.  For `find` and `delete` methods where the return type is an entity, array of entity, or parameterized type such as `List<MyEntity>` or `Page<MyEntity>`, the entity type is determined from the method return type.  For `count`, `exists`, and other `delete` methods that do not return the entity or accept the entity as a parameter, the entity type cannot be determined from the method signature and a primary entity type must be defined for the repository.

Users of Jakarta Data declare a primary entity type for a repository by inheriting from a built-in repository super interface, such as `BasicRepository`, and specifying the primary entity type as the first type variable. For repositories that do not inherit from a super interface with a type parameter to indicate the primary entity type, life cycle methods on the repository determine the primary entity type. To do so, all life cycle methods where the method parameter is a type, an array of type, or is parameterized with a type that is annotated as an entity, must correspond to the same entity type. The primary entity type is assumed for methods that do not otherwise specify an entity type, such as `countByPriceLessThan`. Methods that require a primary entity type raise `MappingException` if a primary entity type is not provided.


NOTE: A Jakarta Data provider might go beyond what is required by this specification and support abstract methods which do not fall into any of the above categories. Such functionality is not defined by this specification, and so applications with repositories which declare such methods are not portable between providers.

The subsections below specify the rules that an abstract method declaration must observe so that the Jakarta Data implementation is able to provide an implementation of the abstract method.

- If every abstract method of a repository complies with the rules specified below, then the Jakarta Data implementation must provide an implementation of the repository.
- Otherwise, if a repository declares an abstract method which does not comply with the rules specified below, or makes use of functionality which is not supported by the Jakarta Data implementation, then an error might be produced by the Jakarta Data implementation at build time or at runtime.

The portability of a given repository interface between Jakarta Data implementations depends on the portability of the entity types it uses.
If an entity class is not portable between given implementations, then any repository which uses the entity class is also unportable between those implementations.

NOTE: Additional portability guarantees may be provided by specifications which extend this specification, specializing to a given class of datastore.

=== Lifecycle methods

A _lifecycle method_ is an abstract method annotated with a _lifecycle annotation_.
Lifecycle methods allow the program to make changes to persistent data in the data store.

A lifecycle method must be annotated with a lifecycle annotation. The method signature of the lifecycle method, including its return type, must follow the requirements that are specified by the JavaDoc of the lifecycle annotation.

Lifecycle method signatures follow one of these generic patterns:

[source,java]
----
@Lifecycle
void lifecycle(Entity e);
----

[source,java]
----
@Lifecycle
Entity lifecycle(Entity e);
----

where `Lifecycle` is a lifecycle annotation, `lifecycle` is the arbitrary name of the method, and `Entity` is either `E`, `Iterable<E>`, or `E[]`, where `E` is a concrete entity class.

This specification defines four built-in lifecycle annotations: `@Insert`, `@Update`, `@Delete`, and `@Save`. The semantics of these annotations is defined in their Javadoc.

For example:

[source,java]
----
@Insert 
void insertBook(Book book);
----

Lifecycle methods are not guaranteed to be portable between all providers.

Jakarta Data providers must support lifecycle methods to the extent that the data store is capable of the corresponding operation. If the data store is not capable of the operation, the Jakarta Data provider must raise `UnsupportedOperationException` when the operation is attempted, per the requirements of the JavaDoc for the lifecycle annotation, or the Jakarta Data provider must report the error at compile time.

There is no special programming model for lifecycle annotations.
The Jakarta Data implementation automatically recognizes the lifecycle annotations it supports.

[NOTE]
====
A Jakarta Data provider might extend this specification to define additional lifecycle annotations, or to support lifecycle methods with signatures other than the usual signatures defined above. For example, a provider might support "merge" methods declared as follows:

[source,java]
----
@Merge
Book mergeBook(Book book);
----

Such lifecycle methods are not portable between Jakarta Data providers.
====

=== Annotated Query methods

An _annotated query method_ is an abstract method annotated by a _query annotation_ type.
The query annotation specifies a query in some datastore-native query language.

Each parameter of an annotated query method must either:

- have exactly the same name and type as a named parameter of the query,
- have exactly the same type and position within the parameter list of the method as a positional parameter of the query, or
- be of type `Limit`, `Order`, `PageRequest`, or `Sort`.

A repository with annotated query methods with named parameters must be compiled so that parameter names are preserved in the class file (for example, using `javac -parameters`), or the parameter names must be specified explicitly using the `@Param` annotation.

An annotated query method must not also be annotated with a lifecycle annotation.

The return type of the annotated query method must be consistent with the result type of the query specified by the query annotation.

[NOTE]
====
The result type of a query depends on datastore-native semantics, and so the return type of an annotated query method cannot be specified here.
However, Jakarta Data implementations are strongly encouraged to support the following return types:

- for a query which returns a single result of type `T`, the type `T` itself, or `Optional<T>`,
- for a query which returns many results of type `T`, the types `List<T>`, `Page<T>`, and `T[]`.

Furthermore, implementations are encouraged to support `void` as the return type for a query which never returns a result.
====

This specification defines the built-in `@Query` annotation, which may be used to specify a query written in the <<Jakarta Data Query Language>> defined in the next chapter.

For example, using a named parameter:

[source,java]
----
@Query("where title like :title order by title")
Page<Book> booksByTitle(String title, PageRequest<Book> pageRequest);
----

[source,java]
----
@Query("SELECT p FROM Product p WHERE p.name=:prodname")
Optional<Product> findByName(@Param("prodname") String name);
----

Or, using a positional parameter:

[source,java]
----
@Query("delete from Book where isbn = ?1")
void deleteBook(String isbn);
----

Programs which make use of annotated query methods are not portable between providers.

[NOTE]
====
A Jakarta Data provider might extend this specification to define its own query annotation types.
For example, a provider might define a `@SQL` annotation for declaring queries written in SQL.
====

There is no special programming model for query annotations.
The Jakarta Data implementation automatically recognizes the query annotations it supports.

=== Parameter-based automatic query methods

A _parameter-based automatic query method_ is an abstract method annotated with an _automatic query annotation_.

Each automatic query method must be assigned an entity type. The rules for inferring the entity type depend on the semantics of the automatic query annotation. Typically:

- If the automatic query method returns an entity type, the method return type identifies the entity. For example, the return type might be `E`, `Optional<E>`, `Page<E>`, or `List<E>`, where `E` is an entity class. Then the automatic query method would be assigned the entity type `E`.
- If the query does not return an entity type, the entity assigned to the automatic query method is the primary entity type of the repository.

Jakarta Data infers a query based on the parameters of the method. Each parameter must either:

- have exactly the same type and name as a persistent field or property of the entity class, or
- be of type `Limit`, `Order`, `PageRequest`, or `Sort`.

Parameter names map parameters to persistent fields. A repository with parameter-based automatic query methods must either:

- be compiled so that parameter names are preserved in the class file (for example, using `javac -parameters`), or
- explicitly specify the name of the persistent field mapped by each parameter of an automatic query method using the `@By` annotation.

The parameter name or explicit field name specified using `@By` may be a compound name, as specified below in <<Persistent Field Names>>.

This specification defines the built-in automatic query annotations `@Find` and `@Delete`. The semantics of these annotations are specified in their Javadoc. Note that `@Delete` is _both_ a lifecycle annotation _and_ an automatic query annotation. The signature of a repository method annotated `@Delete` must be used to disambiguate the interpretation of the `@Delete` annotation.

For example:

[source,java]
----

@Find
Book bookByIsbn(String isbn);

@Find
List<Book> booksByYear(Year year, Sort order, Limit limit);

@Find
Page<Book> find(@By("year") Year publishedIn,
                @By("genre") Category type,
                PageRequest<Book> pageRequest);
----

Automatic query methods annotated with `@Find` or `@Delete` _are_ portable between providers.

[NOTE]
====
A Jakarta Data provider might extend this specification to define its own automatic query annotation types.
In this case, an automatic query method is _not_ portable between providers.
====

=== Resource accessor methods

A _resource accessor method_ is a method with no parameters which returns a type supported by the Jakarta Data provider.
The purpose of this method is to provide the program with direct access to the data store.

For example, if the Jakarta Data provider is based on JDBC, the return type might be `java.sql.Connection` or `javax.sql.DataSource`.
Or, if the Jakarta Data provider is backed by Jakarta Persistence, the return type might be `jakarta.persistence.EntityManager`.

The Jakarta Data provider recognizes the connection types it supports and implements the method such that it returns an instance of the type of resource. If the resource type implements `java.lang.AutoCloseable` and the resource is obtained within the scope of a default method of the repository, then the Jakarta Data provider automatically closes the resource upon completion of the default method. If the method for obtaining the resource is invoked outside the scope of a default method of the repository, then the user is responsible for closing the resource instance.

[NOTE]
A Jakarta Data implementation might allow a resource accessor method to be annotated with additional metadata providing information about the connection.

For example:

[source,java]
----
Connection connection();

default void cleanup() {
    try (Statement s = connection().createStatement()) {
        s.executeUpdate("truncate table books");
    }
}
----

A repository may have at most one resource accessor method.

=== Conflicting Repository Method Annotations

Annotations like `@Find`, `@Query`, `@Insert`, `@Update`, `@Delete`, and `@Save` are mutually-exclusive. A given method of a repository interface may have at most one:

- `@Find` annotation,
- lifecycle annotation, or
- query annotation.

If a method of a repository interface has more than one such annotation, the annotated repository method must raise
`UnsupportedOperationException` every time it is called. Alternatively, a Jakarta Data provider is permitted to
reject such a method declaration at compile time.


=== Query by Method Name

The Query by method mechanism allows for creating query commands by naming convention.

[source,java]
----
@Repository
public interface ProductRepository extends BasicRepository<Product, Long> {

  List<Product> findByName(String name);

  @OrderBy("price")
  List<Product> findByNameLike(String namePattern);

  @OrderBy(value = "price", descending = true)
  List<Product> findByNameLikeAndPriceLessThan(String namePattern, float priceBelow);

}
----

The parsing of query method names follows a specific format:

- The method name consists of the subject, the predicate, and optionally the order clause.
- The subject begins with the action (such as `find` or `delete`) and is optionally followed by an expression (for example, `First10`), followed by any number of other characters, followed by `By`.
- The predicate defines the query's condition or filtering criteria, where multiple conditions are delimited by `And` or `Or`. For example, `PriceLessThanAndNameLike`.
- The order clause, which is optional, begins with `OrderBy` and consists of an ordered collection of entity attributes by which to sort results, delimited by `Asc` or `Desc` to specify the sort direction of the preceding attribute.
- The method name is formed by combining the subject, predicate, and order clause, in that order.

NOTE: This specification uses the terms subject and predicate in a way that aligns with industry terminology rather than how they are defined in English grammar.

Queries can also handle entities with relation attributes by specifying the relationship using dot notation, with the dot converted to underscore so that it is a valid character within the method name. See Scenario 3 below for an example.

Example query methods:

- `findByName(String name)`: Find entities by the 'name' property.
- `findByAgeGreaterThan(int age)`: Find entities where 'age' is greater than the specified value.
- `findByAuthorName(String authorName)`: Find entities by the 'authorName' property of a related entity.
- `findByCategoryNameAndPriceLessThan(String categoryName, double price)`: Find entities by 'categoryName' and 'price' properties, applying an 'And' condition.

==== BNF Grammar for Query Methods

Query methods allow developers to create database queries using method naming conventions. These methods consist of a subject, predicate, and optional order clause. This BNF notation provides a structured representation for understanding and implementing these powerful querying techniques in your applications.

[source,bnf]
----
<query-method> ::= <subject> <predicate> [<order-clause>]
<subject> ::= (<action> | "find" <find-expression>) [<ignored-text>] "By"
<action> ::= "find" | "delete" | "update" | "count" | "exists"
<find-expression> ::= "First" [<positive-integer>]
<predicate> ::= <condition> { ("And" | "Or") <condition> }
<condition> ::= <property> ["IgnoreCase"] ["Not"] [<operator>]
<operator> ::= "Contains" | "EndsWith" | "StartsWith" | "LessThan"| "LessThanEqual" | "GreaterThan" | "GreaterThanEqual" | "Between" | "Like" | "In" | "Null" | "True" | "False"
<property> ::= <identifier> | <identifier> "_" <property>
<identifier> ::= <word>
<positive-integer> ::= <digit> { <digit> }
<order-clause> ::= "OrderBy" { <order-item> } ( <order-item> | <property> )
<order-item> ::= <property> ("Asc" | "Desc")
----

Explanation of the BNF elements:

- `<query-method>`: Represents a query method, which consists of a subject, a predicate, and an optional order clause.
- `<subject>`: Defines the action (e.g., "find" or "delete") followed by an optional expression and "By."
- `<action>`: Specifies the action, such as "find" or "delete."
- `<find-expression>`: Represents an optional expression for find operations, such as "First10."
- `<ignored-text>`: Optional text that does not contain "By".
- `<predicate>`: Represents the query's condition or filtering criteria, which can include multiple conditions separated by "And" or "Or."
- `<condition>`: Specifies a property and an operator for the condition.
- `<operator>`: Defines the operator for the condition, like "Between" or "LessThan."
- `<property>`: Represents a property name, which can include underscores for nested properties.
- `<identifier>`: Represents a word (e.g., property names, action names, etc.).
- `<positive-integer>`: Represents a whole number greater than zero.
- `<order-clause>`: Specifies the optional order clause, starting with "OrderBy" and followed by one or more order items.
- `<order-item>`: Represents an ordered collection of entity attributes by which to sort results, including an optional "Asc" or "Desc" to specify the sort direction.

==== Query by Method Name Keywords

The following table lists the _Query by Method Name_ keywords that must be supported by Jakarta Data providers, except where explicitly indicated for a type of database.

|===
|Keyword |Description| Not Required For

|findBy
|General query method returning entities.
|Key-value, Wide-Column

|deleteBy
|Delete query method returning either no result (void) or the delete count.
|Key-value, Wide-Column

|countBy
|Count projection returning a numeric result.
|Key-value, Wide-Column

|existsBy
|Exists projection, returning as a `boolean` result.
|Key-value, Wide-Column
|===

[NOTE]
====
The "Not Required For" column indicates the database types for which the respective keyword is not required or applicable.
====
Jakarta Data implementations must support the following list of Query by Method Name keywords, except where indicated for a database type. A repository method must raise `java.lang.UnsupportedOperationException` or a more specific subclass of the exception if the database does not provide the requested functionality.

|===
|Keyword |Description | Method signature Sample| Not Required For

|And
|The `And` operator requires both conditions to match.
|findByNameAndYear
|Key-value, Wide-Column

|Or
|The `Or` operator requires at least one of the conditions to match.
|findByNameOrYear
|Key-value, Wide-Column

|Not
|Negates the condition that immediately follows the `Not` keyword. When used without a subsequent keyword, means not equal to.
|findByNameNotLike
|Key-value, Wide-Column

|Between
|Find results where the property is between (inclusive of) the given values
|findByDateBetween
|Key-value, Wide-Column

|Contains
|Matches String values with the given substring, which can be a pattern.
|findByProductNameContains
|Key-value, Wide-Column, Document, Graph

|EndsWith
|Matches String values with the given ending, which can be a pattern.
|findByProductNameEndsWith
|Key-value, Wide-Column, Document, Graph

|First
|For a query with ordered results, limits the quantity of results to the number following First, or if there is no subsequent number, to a single result.
|findFirst10By
|Key-value, Wide-Column, Document, Graph

|LessThan
|Find results where the property is less than the given value
|findByAgeLessThan
|Key-value, Wide-Column

|GreaterThan
|Find results where the property is greater than the given value
|findByAgeGreaterThan
|Key-value, Wide-Column

|LessThanEqual
|Find results where the property is less than or equal to the given value
|findByAgeLessThanEqual
|Key-value, Wide-Column

|GreaterThanEqual
|Find results where the property is greater than or equal to the given value
|findByAgeGreaterThanEqual
|Key-value, Wide-Column

|Like
|Matches String values against the given pattern.
|findByTitleLike
|Key-value, Wide-Column, Document, Graph

|IgnoreCase
|Requests that string values be compared independent of case for query conditions and ordering.
|findByStreetNameIgnoreCaseLike
|Key-value, Wide-Column, Document, Graph

|In
|Find results where the property is one of the values that are contained within the given list
|findByIdIn
|Key-value, Wide-Column, Document, Graph

|Null
|Finds results where the property has a null value.
|findByYearRetiredNull
|Key-value, Wide-Column, Document, Graph

|StartsWith
|Matches String values with the given beginning, which can be a pattern.
|findByFirstNameStartsWith
|Key-value, Wide-Column, Document, Graph

|True
|Finds results where the property has a boolean value of true.
|findBySalariedTrue
|Key-value, Wide-Column

|False
|Finds results where the property has a boolean value of false.
|findByCompletedFalse
|Key-value, Wide-Column

|OrderBy
|Specify a static sorting order followed by the property path and direction of ascending.
|findByNameOrderByAge
|Key-value, Wide-Column

|OrderBy____Desc
|Specify a static sorting order followed by the property path and direction of descending.
|findByNameOrderByAgeDesc
|Key-value, Wide-Column

|OrderBy____Asc
|Specify a static sorting order followed by the property path and direction of ascending.
|findByNameOrderByAgeAsc
|Key-value, Wide-Column

|OrderBy____(Asc\|Desc)*(Asc\|Desc)
|Specify several static sorting orders
|findByNameOrderByAgeAscNameDescYearAsc
|Key-value, Wide-Column

|===

[NOTE]
====
The "Not Required For" column indicates the database types for which the respective keyword is not required or applicable.
====

===== Patterns

Wildcard characters for patterns are determined by the data access provider. For relational databases, `_` matches any one character and `%` matches 0 or more characters.

===== Logical Operator Precedence

For relational databases, the logical operator `And` takes precedence over `Or`, meaning that `And` is evaluated on conditions before `Or` when both are specified on the same method. For other database types, the precedence is limited to the capabilities of the database. For example, some graph databases are limited to precedence in traversal order.

==== Return Types

Refer to the Jakarta Data module JavaDoc section on "Return Types for Repository Methods" for a listing of valid return types for methods using Query by Method Name.

=== Special Parameters for Limits, Sorting, and Pagination

An <<Annotated Query methods,annotated>>, <<Parameter-based automatic query methods,parameter-based>>, or <<Query by Method Name,method name>> query method may have _special parameters_ of type `Limit`, `Order`, `Sort`, or `PageRequest` if the method return type indicates that the method may return multiple entities, that is, if the return type is:

- an array type,
- `List` or `Stream`, or
- `Page` or `CursoredPage`.

A special parameter controls which query results are returned to the caller of a repository method, or in what order the results are returned:

- a `Limit` allows the query results to be limited to a given range defined in terms of an offset and maximum number of results,
- a `Sort` or `Order` allows the query results to be sorted by a given entity field or list of fields, respectively, and
- a `PageRequest` combines a range with optional sorting criteria, and a parameter of this type must be declared when the repository method returns a `Page` of results, as specified below in <<Offset-based Pagination>>, or a `CursoredPage`, as specified in <<Cursor-based Pagination>>.

A repository method must throw `UnsupportedOperationException` if it has:

- more than one parameter of type `PageRequest` or `Limit`,
- a parameter of type `PageRequest` and a parameter of type `Limit`,
- a parameter of type `PageRequest` or `Limit`, in combination with the keyword `First`, or
- more than one parameter of type `Order`.

Alternatively, a Jakarta Data provider is permitted to reject such a repository method declaration at compile time.

A repository method must throw `IllegalArgumentException` if it is called with an argument or arguments of type `Sort` or `Order` and a separate argument of type `PageRequest` with nonempty sort criteria.

A repository method must throw `DataException` if the database is incapable of ordering the query results using the given sort criteria.

The following example demonstrates the use of special parameters:

[source,java]
----
@Repository
public interface ProductRepository extends BasicRepository<Product, Long> {

    List<Product> findByName(String name, PageRequest<Product> pageRequest);

    List<Product> findByNameLike(String pattern, Limit max, Sort<?>... sorts);

}
----

An instance of `Sort` may be obtained by specifying an entity field name:

[source,java]
----
Sort nameAscending = Sort.asc("name");
----

Even better, the <<Type-safe Access to Entity Attributes,static metamodel>> may be used to obtain an instance of `Sort` in a typesafe way:

[source,java]
----
Sort<Employee> nameAscending = _Employee.name.asc();
----

This `PageRequest` combines sorting with a starting page and maximum page size:

[source,java]
----
PageRequest<Product> pageRequest =
        PageRequest.of(Product.class)
                   .size(20).page(1)
                   .sortBy(_Product.price.desc());
List<Product> first20 = products.findByName(name, pageRequest);
----

=== Precedence of Sort Criteria

The specification defines different ways of providing sort criteria on queries. This section discusses how these different mechanisms relate to each other.

==== Sort Criteria within Query Language

Sort criteria can be hard-coded directly within query language by making use of the `@Query` annotation. A repository method that is annotated with `@Query` with a value that contains an `ORDER BY` clause (or query language equivalent) must not provide sort criteria via the other mechanisms.

A repository method that is annotated with `@Query` with a value that does not contain an `ORDER BY` clause and ends with a `WHERE` clause (or query language equivalents to these) can use other mechanisms that are defined by this specification for providing sort criteria.

==== Static Mechanisms for Sort Criteria

Sort criteria is provided statically for a repository method by using the `OrderBy` keyword or by annotating the method with one or more `@OrderBy` annotations. The `OrderBy` keyword cannot be intermixed with the `@OrderBy` annotation or the `@Query` annotation. Static sort criteria takes precedence over dynamic sort criteria in that static sort criteria is evaluated first. When static sort criteria sorts entities to the same position, dynamic sort criteria is applied to further order those entities.

==== Dynamic Mechanisms for Sort Criteria

Sort criteria is provided dynamically to repository methods either via `Sort` parameters or via a `PageRequest` or `Order` parameter that has one or more `Sort` values. `Sort` and `PageRequest` containing `Sort` must not both be provided to the same method. Similarly, `Order` and `PageRequest` containing `Sort` must not both be provided to the same method.

==== Examples of Sort Criteria Precedence

The following examples work through scenarios where static and dynamic sort criteria are provided to the same method.

[source,java]
----
// Sorts first by type. When type is the same, applies the PageRequest's sort criteria
Page<User> findByNameStartsWithOrderByType(String namePrefix, PageRequest<User> pagination);

// Sorts first by type. When type is the same, applies the criteria in the Sorts
List<User> findByNameStartsWithOrderByType(String namePrefix, Sort<?>... sorts);

// Sorts first by age. When age is the same, applies the PageRequest's sort criteria
@OrderBy("age")
Page<User> findByNameStartsWith(String namePrefix, PageRequest<User> pagination);

// Sorts first by age. When age is the same, applies the criteria in the Sorts
@OrderBy("age")
List<User> findByNameStartsWith(String namePrefix, Sort<?>... sorts);

// Sorts first by name. When name is the same, applies the PageRequest's sort criteria
@Query("SELECT u FROM User u WHERE (u.age > ?1)")
@OrderBy("name")
CursoredPage<User> olderThan(int age, PageRequest<User> pagination);
----

=== Pagination in Jakarta Data

Dividing up large sets of data into pages is a beneficial strategy for data access and retrieval in many applications, including those developed in Java. Pagination helps improve the efficiency of handling large datasets in a way that is also user-friendly. In Jakarta Data, APIs are provided to help Java developers efficiently manage and navigate through data.

Jakarta Data supports two types of pagination: offset-based and cursor-based. These approaches differ in how they manage and retrieve paginated data:

Offset pagination is the more traditional form based on position relative to the first record in the dataset. It is typically used with a fixed page size, where a specified number of records is retrieved starting from a given offset position.

Cursor-based pagination, also known as seek method or keyset pagination, uses a unique key or unique combination of values (referred to as the key) to navigate the dataset relative to the first or last record of the current page. Cursor-based pagination is typically used with fixed page sizes but can accommodate varying the page size if desired. It is more robust when dealing with datasets where the underlying data might change and offers the the potential for improved performance by avoiding the need to scan records prior to the cursor.


The critical differences between offset-based and cursor-based pagination lie in their retrieval methods:

- Offset-based pagination uses a fixed page size and retrieves data based on page number and size.
- Cursor-based pagination relies on a unique key or unique combination of values (the key) for an entity relative to which it determines the next page or previous page.

==== Offset-based Pagination

Offset pagination is a popular method for managing and retrieving large datasets efficiently. It is based on dividing the dataset into pages containing a specified number of elements. This method allows developers to retrieve a subset of the dataset by identifying the page number and the maximum number of elements per page.

Offset pagination is motivated by the need to provide efficient navigation through large datasets. Loading an entire dataset into memory at once can be resource-intensive and lead to performance issues. By breaking the dataset into smaller, manageable pages, offset pagination improves performance, reduces resource consumption, and enhances the overall user experience.

Offset pagination offers several key features that make it a valuable approach for managing and retrieving large datasets in a controlled and efficient manner:

- *Page Size*: The maximum number of elements to be included in each page is known as the page size. This parameter determines the subset of data retrieved with each pagination request.

- *Page Number*: The page number indicates which subset of the dataset to retrieve. It typically starts from 1, representing the first page, and increments with each subsequent page.

- *Efficient Navigation*: Offset pagination allows efficient dataset navigation. By specifying the desired page and page size, developers can control the data retrieved, optimizing memory usage and processing time.

- *Sequential Order*: Elements are retrieved sequentially based on predefined criteria, such as ascending or descending order of a specific attribute, like an ID.

===== Requirements when using Offset Pagination

The following requirements must be met when using offset-based pagination:

* The repository method signature must return `Page`. A repository method with return type of `Page` must raise `UnsupportedOperationException` if the database is incapable of offset pagination.
* The repository method signature must accept a `PageRequest` parameter.
* Sort criteria must be provided and should be minimal.
* The combination of provided sort criteria must define a deterministic ordering of entities.
* The entities within each page must be ordered according to the provided sort criteria.
* If `PageRequest.requestTotal()` returns `true`, the `Page` should contain accurate information about the total number of pages and total number of elements across all pages. Otherwise, if `PageRequest.requestTotal()` returns `false`, the operations `Page.totalElements()` and `Page.totalPages()` throw `IllegalStateException`.
* Except for the highest numbered page, the Jakarta Data provider must return full pages consisting of the maximum page size number of entities.
* Page numbers for offset pagination are computed by taking the entity's 1-based offset after sorting, dividing it by the maximum page size, and rounding up. For example, the 52nd entity is on page 6 when the maximum page size is 10, because 52 / 10 rounded up is 6. Note that the first page number is always 1.

===== Scenario: Person Entity and People Repository

Consider a scenario with a `Person` entity and a corresponding `People` repository:

[source,java]
----

public class Person {
    private Long id;
    private String name;
}

@Repository
public interface People extends BasicRepository<Person, Long> {
}
----



The dataset contains the following elements:

[source,json]
----
[
   {"id":1, "name":"Lin Le Marchant"},
   {"id":2, "name":"Corri Davidou"},
   {"id":3, "name":"Alyse Dadson"},
   {"id":4, "name":"Orelle Roughey"},
   {"id":5, "name":"Jaquith Wealthall"},
   {"id":6, "name":"Boothe Martinson"},
   {"id":7, "name":"Patten Bedell"},
   {"id":8, "name":"Danita Pilipyak"},
   {"id":9, "name":"Harlene Branigan"},
   {"id":10, "name":"Boothe Martinson"}
]
----


Code Execution:

[source,java]
----

@Inject
People people;

Page<Person> page = people.findAll(PageRequest.of(Person.class)
                                              .page(1)
                                              .size(2)
                                              .sortBy(Sort.asc("id")));
----

Resulting Page Content:

[source,json]
----
[
   {"id":1, "name":"Lin Le Marchant"},
   {"id":2, "name":"Corri Davidou"}
]
----


Next Page Execution:

[source,java]
----
if (page.hasNext()) {
   PageRequest<Person> nextPageRequest = page.nextPageRequest();
   Page<Person> page2 = people.findAll(nextPageRequest);
}
----


Resulting Page Content:

[source,json]
----
[
   {"id":3, "name":"Alyse Dadson"},
   {"id":4, "name":"Orelle Roughey"}
]
----


In this scenario, each page represents a subset of the dataset, and developers can navigate through the pages efficiently using offset pagination.

Offset pagination is a valuable tool for Java developers when dealing with large datasets, providing control, efficiency, and a seamless user experience.

==== Cursor-based Pagination

Cursor-based pagination aims to reduce missed and duplicate results across pages by querying relative to the observed values of entity properties that constitute the sorting criteria. Cursor-based pagination can also offer an improvement in performance because it avoids fetching and ordering results from prior pages by causing those results to be non-matching. A Jakarta Data provider appends additional conditions to the query and tracks cursor-based values automatically when `CursoredPage` is used as the repository method return type. The application invokes `nextPageRequest` or `previousPageRequest` on the cursor-based aware slice or page to obtain a `PageRequest` which keeps track of the cursor-based values.

For example,

[source,java]
----
@Repository
public interface CustomerRepository extends BasicRepository<Customer, Long> {
  CursoredPage<Customer> findByZipcodeOrderByLastNameAscFirstNameAscIdAsc(
                                 int zipcode, PageRequest<Customer> pageRequest);
}
----

You can obtain the initial page relative to an offset and subsequent pages relative to the last entity of the current page as follows,

[source,java]
----
PageRequest<Customer> pageRequest = PageRequest.of(Customer.class).size(50);
Page<Customer> page = customers.findByZipcodeOrderByLastNameAscFirstNameAscIdAsc(
                                55901, pageRequest);
if (page.hasNext()) {
  pageRequest = page.nextPageRequest();
  page = customers.findByZipcodeOrderByLastNameAscFirstNameAscIdAsc(55901, pageRequest);
  ...
}
----

Or you can obtain the next (or previous) page relative to a known entity,

[source,java]
----
Customer c = ...
PageRequest<Customer> p = PageRequest.of(Customer.class).size(50).afterKey(c.lastName, c.firstName, c.id);
page = customers.findByZipcodeOrderByLastNameAscFirstNameAscIdAsc(55902, p);
----

The sort criteria for a repository method that performs cursor-based pagination must uniquely identify each entity and must be provided by:

* `OrderBy` name pattern of the repository method (as in the examples above) or `@OrderBy` annotation(s) on the repository method.
* `Sort` parameters of the `PageRequest` that is supplied to the repository method.

The values of the entity attributes of the combined sort criteria define the cursor for cursor-based cursor based pagination. Within the cursor, each entity attribute has the same sorting and order of precedence that it has within the combined sort criteria.

===== Example of Appending to Queries for Cursor-based Pagination

Without cursor-based pagination, a Jakarta Data provider that is based on Jakarta Persistence might compose the following JPQL for the `findByZipcodeOrderByLastNameAscFirstNameAscIdAsc` repository method from the prior example:

[source,jpql]
----
SELECT o FROM Customer o WHERE (o.zipCode = ?1)
                         ORDER BY o.lastName ASC, o.firstName ASC, o.id ASC
----

When cursor-based pagination is used, the keys values from the `Cursor` of the `PageRequest` are available as query parameters, allowing the Jakarta Data provider to append additional query conditions. For example,

[source,jpql]
----
SELECT o FROM Customer o WHERE (o.zipCode = ?1)
                           AND (   (o.lastName > ?2)
                                OR (o.lastName = ?2 AND o.firstName > ?3)
                                OR (o.lastName = ?2 AND o.firstName = ?3 AND o.id > ?4)
                               )
                         ORDER BY o.lastName ASC, o.firstName ASC, o.id ASC
----

===== Avoiding Missed and Duplicate Results

Because searching for the next page of results is relative to a last known position, it is possible with cursor-based pagination to allow some types of updates to data while pages are being traversed without causing missed results or duplicates to appear. If you add entities to a prior position in the traversal of pages, the shift forward of numerical position of existing entities will not cause duplicates entities to appear in your continued traversal of subsequent pages because cursor-based pagination does not query based on a numerical position. If you remove entities from a prior position in the traversal of pages, the shift backward of numerical position of existing entities will not cause missed entities in your continued traversal of subsequent pages because keyset pagination does not query based on a numerical position.

Other types of updates to data, however, will cause duplicate or missed results. If you modify entity properties which are used as the sort criteria, cursor-based pagination cannot prevent the same entity from appearing again or never appearing due to the altered values. If you add an entity that you previously removed, whether with different values or the same values, cursor-based pagination cannot prevent the entity from being missed or possibly appearing a second time due to its changed values.

===== Restrictions on use of Cursor-based Pagination

* The repository method signature must return `CursoredPage`. A repository method with return type of `CursoredPage` must raise `UnsupportedOperationException` if the database is incapable of cursor-based pagination.
* The repository method signature must accept a `PageRequest` parameter.
* Sort criteria must be provided and should be minimal.
* The combination of provided sort criteria must uniquely identify each entity such that the sort criteria defines a deterministic ordering of entities.
* The entities within each page must be ordered according to the provided sort criteria.
* Page numbers for cursor-based pagination are estimated relative to prior page requests or the observed absence of further results and are not accurate. Page numbers must not be relied upon when using cursor-based pagination.
* Page totals and result totals are not accurate for cursor-based pagination and must not be relied upon.
* A next or previous page can end up being empty. You cannot obtain a next or previous `PageRequest` from an empty page because there are no key values relative to which to query.
* A repository method that is annotated with `@Query` and performs cursor-based pagination must omit the `ORDER BY` clause from the provided query and instead must supply the sort criteria via `@OrderBy` annotations or `Sort` criteria of `PageRequest`. The provided query must end with a `WHERE` clause to which additional conditions can be appended by the Jakarta Data provider. The Jakarta Data provider is not expected to parse query text that is provided by the application.

===== Cursor-based Pagination Example with Sorts

Here is an example where an application uses `@Query` to provide a partial query to which the Jakarta Data provider can generate and append additional query conditions and an `ORDER BY` clause.

[source,java]
----
@Repository
public interface CustomerRepository extends BasicRepository<Customer, Long> {
  @Query("SELECT o FROM Customer o WHERE (o.totalSpent / o.totalPurchases > ?1)")
  CursoredPage<Customer> withAveragePurchaseAbove(float minimum, PageRequest<Customer> pageRequest);
}
----

Example traversal of pages:

[source,java]
----
PageRequest<Customer> pageRequest = Order.by(_Customer.yearBorn.desc(),
                                             _Customer.name.asc(),
                                             _Customer.id.asc())
                                         .pageSize(25);
do {
  page = customers.withAveragePurchaseAbove(50.0f, pageRequest);
  ...
  if (page.hasNext())
    pageRequest = page.nextPageRequest();
} while (page.hasNext());
----

===== Example with Before/After Cursor

In this example, the application uses a cursor to request pages in forward and previous direction from a specific value, which is the price for a matching product.

[source,java]
----
@Repository
public interface Products extends CrudRepository<Product, Long> {
  CursoredPage<Product> findByNameLike(String namePattern, PageRequest<Product> pageRequest);
}
----

Obtaining the next 10 products that cost $50.00 or more:

[source,java]
----
float priceMidpoint = 50.0f;
PageRequest<Product> pageRequest = Order.by(_Product.price.asc(), _Product.id.asc())
                                        .pageSize(10)
                                        .afterKey(priceMidpoint, 0L);
CursoredPage<Product> moreExpensive = products.findByNameLike(pattern, pageRequest);
----

Obtaining the previous 10 products:

[source,java]
----
if (moreExpensive.hasContent())
    pageRequest = pageRequest.beforeCursor(moreExpensive.getCursor(0));
else
    pageRequest = pageRequest.beforeKey(priceMidpoint, 1L);
CursoredPage<Product> lessExpensive = products.findByNameLike(pattern, pageRequest);
----

===== Example with Combined Sort Criteria

In this example, the application uses `OrderBy` to define a subset of the sort criteria during development time, but also uses `Sort` to dynamically determine more fine-grained sorting when all of the static sort criteria matches. In this case the repository query is written to always order `Car` entities with a vehicle condition of `VehicleCondition.NEW` ahead of those with `VehicleCondition.USED`.

[source,java]
----
@Repository
public interface Products extends CrudRepository<Product, Long> {
  @OrderBy(_Car.vehicleCondition)
  CursoredPage<Car> find(@By(_Car.make) String manufacturer,
                            @By(_Car.model) String model,
                            PageRequest<Car> pageRequest);
}
----

The above criteria does not uniquely identify `Car` entities. After sorting on the vehicle condition, finer grained sorting is provided dynamically by the `PageRequest`, in this case the vehicle price followed by the unique Vehicle Identification Number (VIN). It is a good practice for the final sort criterion to be a unique identifier of the entity to ensure a deterministic ordering.

[source,java]
----
PageRequest<Car> page1Request = Order.by(_Car.price.desc(), _Car.vin.asc())
                                     .pageSize(25);
CursoredPage<Car> page1 = cars.find(make, model, page1Request);
----

The query results are ordered first by vehicle condition. All resulting entities with the same vehicle condition are subsequently ordered by their price in descending order. All resulting entities with the same vehicle condition and price are ordered alphabetically by their VIN. The end user requests the next page of results. If the application still has access to the page at this point, it can use `page.nextPageRequest()` to obtain a request for the next page of results. In this case, the Jakarta Data provider computes the cursor from the vehicle condition, price, and VIN of the final `Car` entity of the page and includes the cursor in the resulting `PageRequest` instance. Alternatively, the application does not need access to the page if it obtained the cursor or the vehicle condition, price, and VIN values that make up the cursor. In this case, it can construct a new `PageRequest`,

[source,java]
----
PageRequest<Car> page2Request = Order.by(_Car.price.desc(), _Car.vin.asc())
                                     .page(2) // cosmetic when using a cursor
                                     .size(25)
                                     .afterKey(lastCar.vehicleCondition,
                                               lastCar.price,
                                               lastCar.vin);
CursoredPage<Car> page2 = cars.find(make, model, page2Request);
----

===== Scenario: Person Entity and People Repository

This cursor-based pagination scenario uses the same `Person` entity and example dataset from the offset-based pagination scenario, but orders it by `name` and then by `id`,

[source,json]
----
[
   {"id":3, "name":"Alyse Dadson"},
   {"id":6, "name":"Boothe Martinson"},
   {"id":10, "name":"Boothe Martinson"},
   {"id":2, "name":"Corri Davidou"},
   {"id":8, "name":"Danita Pilipyak"},
   {"id":9, "name":"Harlene Branigan"},
   {"id":5, "name":"Jaquith Wealthall"},
   {"id":1, "name":"Lin Le Marchant"},
   {"id":4, "name":"Orelle Roughey"},
   {"id":7, "name":"Patten Bedell"}
]
----

[source,java]
----
@Repository
public interface People extends BasicRepository<Person, Long> {
    @Find
    CursoredPage<Person> findAll(PageRequest<Person> pagination);
}
----

Code Execution:

[source,java]
----
@Inject
People people;

PageRequest<Person> firstPageRequest = PageRequest.of(Person.class)
                                                  .size(4)
                                                  .sortBy(Sort.asc("name"),
                                                          Sort.asc("id"));
CursoredPage<Person> page = people.findAll(firstPageRequest);
----

Resulting Page Content:

[source,json]
----
[
   {"id":3, "name":"Alyse Dadson"},
   {"id":6, "name":"Boothe Martinson"},
   {"id":10, "name":"Boothe Martinson"},
   {"id":2, "name":"Corri Davidou"}
]
----


Deletion of an Entity:

----
// The user decides to remove one of the entities that has the same name,
people.deleteById(10);
----


Next Page Execution:

[source,java]
----
if (page.hasNext()) {
   PageRequest<Person> nextPageRequest = page.nextPageRequest();
   CursoredPage<Person> page2 = people.findAll(nextPageRequest);
}
----


Resulting Page Content:

[source,json]
----
[
   {"id":8, "name":"Danita Pilipyak"},
   {"id":9, "name":"Harlene Branigan"},
   {"id":5, "name":"Jaquith Wealthall"},
   {"id":1, "name":"Lin Le Marchant"}
]
----

It should be noted, the above result is different than what would be retrieved with offset-based pagination, where the removal of an entity from the first page shifts the offset for entries 5 through 8 to start from `{"id":9, "name":"Harlene Branigan"}`, skipping over `{"id":8, "name":"Danita Pilipyak"}` that becomes offset position 4 after the removal. Cursor-based pagination does not skip the entity because it queries relative to a cursor position, starting from the next entity after `{"id":2, "name":"Corri Davidou"}`.

=== Precedence of Repository Methods

The following order, with the lower number having higher precedence, is used when interpreting the meaning of repository methods.

1. If the method is a Java default method, then its provided implementation is used.
2. If the method has a _Resource Accessor Method_ return type, then the method is implemented as a _Resource Accessor Method_.
3. If the method is annotated with `@Query`, then the method is implemented to run the corresponding Query Language query.
4. If the method is annotated with `@Find` or a _Life Cycle_ annotation that defines the type of operation (`@Insert`, `@Update`, `@Save`, `@Delete`), then the annotation determines how the method is implemented, along with any applicable data access related annotations that are present on method parameters, according to the _Automatic Query Method_ with _Parameter-based Conditions_ pattern.
5. If the method is named according to the _Query by Method Name_ naming conventions, then the implementation follows the _Query by Method Name_ pattern.

A repository method that does not fit any of the above patterns and is not handled as a vendor-specific extension to the specification must either result in an error at build time or raise `UnsupportedOperationException` at run time.

