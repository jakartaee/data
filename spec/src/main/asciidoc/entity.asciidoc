// Copyright (c) 2022,2024 Contributors to the Eclipse Foundation
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0

== Entity Classes

The notion of an _entity_ is the fundamental building block with which a data model may be constructed.
Abstractly, an entity (or _entity type_) is a schema for data.

- The schema may be as simple as a tuple of types, as is typical in the relational model, or it might be structured, as in document data stores.
- The schema might be explicit, as in the case of SQL DDL declaring a relational table, or it might be implicit, as is commonplace in key/value stores.
- Either way, we assume that the entity is represented in Java as a class, which we call the _entity class_. footnote:[We will not consider generic programs which work with entity data via detyped representations.]

NOTE: When there's no risk of confusion, we often use the word “entity” to mean the entity class, or even an instance of the entity class.

Data represented by an entity is persistent, that is, the data itself outlives any Java process which makes use of it. Thus, it is necessary to maintain an association between instances of Java entity classes and state held in a data store.

- Each persistent instantiation of the schema is distinguishable by a unique _identifier_. For example, a row of a relational database table is identifiable by the value of its primary key.
- Any persistent instantiation of the schema is representable by an instance of the entity class. In a given Java program, multiple entity class instances might represent the same persistent instance of the schema.

In Jakarta Data, the concrete definition of an entity may be understood to encompass the following aspects:

1. The *entity class* itself: An entity class is simple Java object equipped with fields or accessor methods designating each property of the entity. An entity class is identified by an annotation.

2. Its *data schema*: Some data storage technologies require an explicit schema defining the structure and properties of the data the entity represents. For example, a relational database requires that the schema be specified using SQL Data Definition Language (DDL) statements. The schema might be generated by the Jakarta Data provider, from the information available in the Java entity class, or it might be managed independently. When the data store itself does not require an explicit schema, the data schema is implicit.

3. Its *association with a repository*: Each entity class is associated with at least one repository, which exposes operations for retrieving and storing instances of the entity.

NOTE: A Jakarta Data provider might allow the state of a single Jakarta Data entity to be stored across multiple entities in the data store. For example, in Jakarta Persistence, the `@SecondaryTable` annotation allows the state of an entity to be mapped across more than one database table.

=== Programming Model for Entity Classes

A _programming model for entity classes_ specifies:

- a set of restrictions on the implementation of a Java class which allows it to be used as an entity class with a given Jakarta Data provider, and
- a set of annotations allowing the identification of a Java class as an entity class, and further specification of the schema of the entity.

Jakarta Data does not define its own programming model for entities, but instead:

- is compatible with the programming models defined by the Jakarta Persistence and Jakarta NoSQL specifications, and
- allows for vendor-specific entity programming models to be defined by Jakarta Data providers.

This section lays out the core requirements that an entity programming model must satisfy in order to be compatible with Jakarta Data, and for the defining provider to be considered a fully-compliant implementation of this specification.

Every entity programming model specifies an _entity-defining annotation_. For Jakarta Persistence, this is `jakarta.persistence.Entity`. For Jakarta NoSQL, it is `jakarta.nosql.Entity`. A Jakarta Data provider must provide repository implementations for entity classes bearing the entity-defining annotations it supports, and must ignore entity classes with entity-defining annotations it does not support.

NOTE: To maintain clarity and to disambiguate the desired Jakarta Data provider, a single entity class should not mix entity-defining annotations from different providers. For example, an entity class should not be annotated both `jakarta.persistence.Entity` and `jakarta.nosql.Entity`. This practice allows the entity-defining annotation to indicate the desired provider in programs where multiple Jakarta Data providers are available.

Furthermore, an entity programming model must define an annotation which identifies the field or property holding the unique identifier of an entity. For Jakarta Persistence, it is `jakarta.persistence.Id` or `jakarta.persistence.EmbeddedId`. For Jakarta NoSQL, it is `jakarta.nosql.Id`. Alternatively, an entity programming model might allow the identifier field or property to be identified via some convention.

Typically, an entity programming model specifies additional annotations which are used to make the schema of the entity explicit, for example, `jakarta.persistence.Id` and `jakarta.persistence.Column`, or `jakarta.nosql.Id` and `jakarta.nosql.Column`. The nature of such annotations is beyond the scope of this specification.

In a given entity programming model, entity classes might always be mutable, or might always be immutable, or, alternatively, the model might support a mix of mutable and immutable entity classes.

- A programming model which supports immutable entity classes may require that every mutable entity class declare a constructor with no parameters, and might place limits on the visibility of this constructor.
- A programming model which supports the use of immutable entity classes--ideally represented as Java `record` types--would not typically require the existence of such a constructor.

In either case, an entity programming model might place restrictions on the visibility of fields and property accessors of an entity class.

==== Entity Inheritance

An entity programming model might support inheritance between entities.
Two entities are related by inheritance if:

1. the entity classes are related by Java language inheritance, and
2. the Jakarta Data provider supports retrieving and querying the entities in a polymorphic fashion.

It's possible for two entity classes to be related by Java inheritance, but _not_ by entity inheritance in the sense defined here.
An entity programming model specifies which Java inheritance relationships are interpreted as entity inheritance.

When entities are related by inheritance, a query method which returns the entity supertype might also return instances of its subtypes.

The Jakarta Data provider determines how entity classes which participate in an entity inheritance hierarchy "map" to the data schema.
For example, in a relational datastore, all entities in the hierarchy might be stored together on one table, or each entity might have its own dedicated table.

Support for entity inheritance is not required by this specification.

==== Persistent Fields

A field of an entity class may or may not represent state which is persistent in the datastore.
A _persistent field_ has some corresponding representation in the data schema of the entity, for example, it might map to a column or columns in a relational database table.
Any programming model for entity classes must provide well-defined rules for distinguishing fields which are persistent in the datastore from which fields are _transient_, having no persistent representation in the datastore.
Furthermore, the programming model must specify how the Jakarta Data provider accesses the persistent fields of an entity to read and write their values.

Every programming model for entity classes must support _direct field access_, that is, access to the persistent fields of an entity class without triggering any intermediating user-written code such as JavaBeans-style property accessors.
When direct field access is used, every Java field marked with the Java language `transient` modifier must be treated as transient.
A programming model might place constraints on the visibility of persistent fields.
For example, Jakarta Persistence disallows `public` persistent fields.
Every programming model must permit `private` persistent fields.

A programming model for entity classes might also support _property-based access_, that is, access to persistent fields via JavaBeans-style property accessors, or, especially for Java `record` types, via accessor methods combined with constructor-based initialization.
Such programming models should provide an annotation or other convention to distinguish transient properties.
For example, Jakarta Persistence provides `jakarta.persistence.Transient`.
When property-based access is supported, a programming model might place constraints on the visibility of property accessors.
For example, Jakarta Persistence requires that property accessors be `public` or `protected`.
Support for property-based access is not required by this specification.

Jakarta Data distinguishes three kinds of persistent field within entity classes.

- A _basic field_ holds a value belonging to some fundamental data type supported natively by the Jakarta Data Provider. Support for the set of basic types enumerated in the next section below is mandatory for all Jakarta Data providers.
- An _embedded field_ allows the inclusion of the state of a finer-grained Java class within the state of an entity. The type of an embedded field is often a user-written Java class. Support for embedded fields varies depending on the Jakarta Data provider and the database type.
- An _association field_ implements an association between entity types. Support for association fields varies depending on the Jakarta Data provider and the database type.

==== Basic Types

Every Jakarta Data provider must support the following basic types within its programming model:

|===
| Basic Data Type | Description

| Primitive types and wrapper classes
| All Java primitive types, such as `int`, `double`, `boolean`, etc., and their corresponding wrapper types from `java.lang` (e.g., `Integer`, `Double`, `Boolean`).

| `java.lang.String`
| Represents text data.

| `LocalDate`, `LocalDateTime`, `LocalTime`, `Instant` from `java.time`
| Represent date and time-related data.

| `java.util.UUID`
| Universally Unique IDentifier for identifying entities.

| `BigInteger` and `BigDecimal` from `java.math`
| Represent large integer and decimal numbers.

| `byte[]`
| Represents binary data.

| User-defined `enum` types
| Custom enumerated types defined by user-written code.
|===

NOTE: In this specification, "string" means `java.lang.String`, "numeric" means any primitive numeric type, wrapper for a primitive numeric type, `BigInteger`, or `BigDecimal`, and "date/time" means `LocalDate`, `LocalDateTime`, `LocalTime`, or `Instant`.

For example, the following entity class has five basic fields:

[source,java]
----
@Entity
public class Person {
    @Id
    private UUID id;
    private String name;
    private long ssn;
    private LocalDate birthdate;
    private byte[] photo;
}
----

In addition to the types listed above, an entity programming model might support additional domain-specific basic types. This extended set of basic types might include types with a nontrivial internal structure. An entity programming model might even provide mechanisms to convert between user-written types and natively-supported basic types. For example, Jakarta Persistence defines the `AttributeConverter` interface.

NOTE: Many key-value, wide-column, document, and relational databases feature native support for arrays or even associative arrays of these basic types. Unfortunately, the semantics of such types--along with their performance characteristics--are extremely nonuniform, and so support for such types is left undefined by the Jakarta Data specification.

==== Embedded Fields and Embeddable Classes

An _embeddable class_ differs from an entity class in that:

- the embeddable class lacks its own persistent identity, and
- the state of an instance of the embeddable class can only be stored in the database when the instance is referenced directly or indirectly by a "parent" entity class instance.

An _embedded field_ is a field whose type is an embeddable class.

Like entities, embeddable classes may have basic fields, embeddable fields, and association fields, but, unlike entities, they do not have identifier fields.

Like entities, a programming model for entity classes might support mutable embeddable classes, immutable embeddable classes, or both.

A programming model for entity classes might define an annotation that identifies a user-written class as an embeddable class. For example, Jakarta Persistence defines the annotation `jakarta.persistence.Embeddabe`. Alternatively, the programming model might define an annotation that identifies a field as an embedded field. For example, Jakarta Persistence defines the annotation `jakarta.persistence.Embedded`.

There are two natural ways that a Jakarta Data provider might store the state of an instance of an embedded class in a database:

- by _flattening_ the fields of the embeddable class into the data structure representing the parent entity, or
- by _grouping_ the fields of the embedded class into a fine-grained structured type (a UDT, for example).

In a flattened representation of an embedded field, the fields of the embeddable class occur directly alongside the basic fields of the entity class in the data schema of the entity.
There is no representation of the embeddable class itself in the data schema.

For example, consider the following Java classes:

[source,java]
----
@Embeddable
public class Address {
    private String street;
    private String city;
    private String postalCode;
}

@Entity
public class Person {
    @Id
    private Long id;
    private String name;
    private Address address;  // embedded field
}
----

In a document, wide-column, or graph database, the JSON representation of an instance of the `Person` entity might be as follows:

[source,json]
----
{
  "id": 1,
  "name": "John Doe",
  "street": "123 Main St",
  "city": "Sampleville",
  "postalCode": "12345"
}
----

Or, in a relational database, the DDL for the `Person` table might look like this:

[source,sql]
----
create table Person (
    id bigint primary key,
    name varchar,
    street varchar,
    city varchar,
    postalCode varchar
)
----

In a structured representation, the fields of the embeddable class are somehow grouped together in the data schema.

For example, the JSON representation of `Person` might be:

[source,json]
----
{
  "id": 1,
  "name": "John Doe",
  "address":
  {
    "street": "123 Main St",
    "city": "Sampleville",
    "postalCode": "12345"
  }
}
----

Or the SQL DDL could be:

[source,sql]
----
create type Address as (
    street varchar,
    city varchar,
    postalCode varchar
)

create table Person (
    id bigint primary key,
    name varchar,
    address Address
)
----

NOTE: Support for embeddable classes and embedded fields is not required by this specification.
However, every Jakarta Data provider is strongly encouraged to provide support for embeddable classes within its entity programming model.

==== Entity Associations

An association field is a field of an entity class whose declared type is also an entity class.
Given an instance of the first entity class, its association field holds a reference to an instance of a second entity class.

For example, consider the following Java classes:

[source,java]
----
@Entity
public class Author {
    @Id
    private UUID id;
    private String name;
    private List<Book> books;
}

@Entity
public class Book {
    @Id
    private Long id;
    private String title;
    private String category;
    private List<Author> authors;
}
----

In a relational database, these entities might map to the following data schema:

[source,sql]
----
create table Author (
    uuid id primary key,
    name varchar,
)

create table BookAuthor(
    book bigint,
    author uuid,
    primary key (book, author),
    foreign key (author) references Author,
    foreign key (book) references Book
)

create table Book (
    id bigint primary key,
    title varchar,
    category varchar
)
----

NOTE: Support for entity associations is not required by this specification.

=== Entity Names and Persistent Field Names

Entities and their persistent fields may be referenced by name in the query language defined in <<Jakarta Data Query Language>>.

==== Entity Names

Each entity must be assigned an _entity name_ by the provider.
By default, this must be the unqualified Java class name of the entity class.
A programming model for entity classes might provide a way to explicitly specify an entity name.
For example, Jakarta Persistence allows the entity name to be specified via the `name` member of the `@Entity` annotation.

==== Persistent Field Names

Each persistent field of an entity, as defined above in <<Persistent Fields>>, or of an embeddable class, as defined in <<Embedded Fields and Embeddable Classes>>, must be assigned a name, allowing the persistent field to be referenced by an <<Parameter-based automatic query methods,automatic query method>>, a <<Query by Method Name>>, or from a query specified within the <<Annotated Query methods,`@Query` annotation>>.

- when direct field access is used, the name of a persistent field is simply the name of the Java field, but
- when property-based access is used, the name of the field is derived from the accessor methods.

Any programming model for entity classes which supports property-based access must also define a rule for assigning names to persistent fields. Typically, a property with accessors named `getX` and `setX` is assigned a persistent field name obtained by calling `java.beans.Introspector.decapitalize("X")`.

Within a given entity class or embeddable class, names assigned to persistent fields must be unique ignoring case. A Jakarta Data provider is permitted to reject an entity class if two persistent fields would be assigned the same name.

Furthermore, within the context of a given entity, each persistent field of an embeddable class reachable by navigation from the entity class may be assigned a compound name. The compound name is obtained by concatenating the names assigned to each field traversed by navigation from the entity class to the persistent field of the embedded class, optionally joined by a delimiter.

The rule for concatenating compound names depends on the context, and is specified in <<property-name-concatenation>>. The examples in the table assume an `Order` entity has an `address` of type `MailingAddress` with a `zipCode` of type `int`.

[[property-name-concatenation]]
.Field Name Concatenation and Delimiters
[cols="3, 2, ^1, 6"]
|===
| Context | Type | Delimiter | Example

| `@Find` | Parameter name
|`_`
|`@Find List<Order> find(int address_zipCode);`

|`@Query` | Path expression within query
|`.`
|`@Query("FROM Order WHERE address.zipCode = ?1")`

|_Query by Method Name_ | Method name
|`_`
|`List<Order> findByAddress_zipCode(int zip);`

|`Sort` | String argument
|`.` or `_`
|`Sort.asc("address_zipCode")`

|`@By` or `@OrderBy` | Annotation value
|`.` or `_`
|`@Find List<Order> find(@By("address.zipCode") int zip);`
|===

NOTE: Application programmers are strongly encouraged to follow Java's camel case naming standard for fields of entities, relations, and embeddable classes, avoiding underscores in field names. The resolution algorithm for persistent field identification relies on the use of underscore as a delimiter. Adhering to the camel case naming convention ensures consistency and eliminates ambiguity.


==== Persistent Field Names in Query by Method Name

For _Query by Method Name_, the use of delimiters within a compound name is optional. Delimiters may be omitted entirely from a compound name when they are not needed to disambiguate the persistent field to which the name refers. But for a given entity property name, delimiter usage must be consistent: either the delimiter must be used between every pair of persistent field names within the compound name, or it must not occur within the compound name.

Resolution of a persistent field involves the following steps:

1. A persistent field name is extracted from the method name according to the <<BNF Grammar for Query Methods>>. For example, if the query method name is `findByAddressZipCode`, the extracted field name is `AddressZipCode`.

2. The extracted name is matched against the fields of the entity class. If the name assigned to a persistent field of the entity class matches the extracted name, ignoring case, then the extracted name resolves to that field.

3. Otherwise, if no match is found among the fields of the entity, the extracted name is matched against the fields of entity classes and embedded classes reachable from the entity class, interpreting the extracted name as a compound name, as outlined in the previous section, both with and without the optional delimiter. If the compound name assigned to a persistent field matches the extracted name, also interpreted as a compound name, and ignoring case, then the extracted name resolves to that field.

4. If no matching persistent field is found in either of the previous steps, the provider is permitted to reject the query method or to throw `UnsupportedOperationException` when the method is called.

A persistent field name used in a _Query by Method Name_ must not contain a <<Query by Method Name Keywords,keyword>> reserved by _Query by Method Name_.


===== Scenario 1: Person Repository with Unambiguous Resolution

In this scenario, we have the following data model:

[source,java]
----
class Person {
  private Long id;
  private MailingAddress address;
}

class MailingAddress {
  private int zipcode;
}
----

The `Person` entity does not have an `addressZipCode` field, so use of the delimiter is optional. It is valid to write both of the following repository methods, which have the same meaning,

[source,java]
----
List<Person> findByAddressZipCode(int zipCode);
List<Person> findByAddress_zipcode(int zipCode);
----

===== Scenario 2: Order Repository with Resolution that requires a Delimiter

In this scenario, we have the following data model:

[source,java]
----
class Order {
  private Long id;
  private String addressZipCode;
  private MailingAddress address;
}

class MailingAddress {
  private int zipcode;
}
----

The `Order` entity has an `addressZipCode` field, as well as an `address` field for an embeddable class with a `zipcode` field. The method name `findByAddressZipCode` points to the `addressZipCode` field and cannot be used to navigate to the embedded class. To navigate to the `zipcode` field of the embedded class, the delimiter must be used:

[source,java]
----
List<Order> findByAddress_zipcode(int zipCode);
----


=== Type-safe Access to Entity Attributes

Jakarta Data provides a static metamodel that allows entity attributes to be accessed by applications in a type-safe manner.

For each entity class, the application developer or a compile-time annotation processor can define a corresponding metamodel class following a prescribed set of conventions.

- The metamodel class must be annotated with `@StaticMetamodel`, specifying the entity class as its `value`.
- The metamodel class contains one or more `public static` fields corresponding to persistent fields of the entity class.
- The type of each of these fields must be either `java.lang.String`, `jakarta.data.metamodel.Attribute`, or a subinterface of `Attribute` from the package `jakarta.data.metamodel`.

The application can use the field values of the metamodel class to obtain artifacts relating to the entity attribute in a type-safe manner, for example, `_Book.title.asc()` or `Sort.asc(_Book.title.name())` or `Sort.asc(_Book.TITLE)` rather than `Sort.asc("title")`.

==== Application Requirements for a Metamodel Class

When an application programmer writes a static metamodel class for an entity by hand:

- each field corresponding to a persistent field of an entity must have modifiers `public`, `static`, and `final`, and
- the fields must be statically initialized.

The static metamodel class is not required to include a field for every persistent field of the entity.

A convenience implementation of each subinterface of `Attribute` is provided in the package `jakarta.data.metamodel.impl`.

==== Compile-time Annotation Processor Requirements for a Metamodel Class

When an annotation processor generates a static metamodel class for an entity:

- the metamodel class must be annotated with `jakarta.annotation.Generated`,
- each field corresponding to a persistent field of an entity must have modifiers `public`, `static`, and either `final` or `volatile`,
- the name of each field, ignoring case, must match the name of an entity attribute, according to the conventions specified below in <<Conventions for Metamodel Fields>>, and with the `_` character in the field name delimiting the attribute names of hierarchical structures or relationships, such as embedded classes.

The fields may be statically initialized, or they may be initialized by the provider during system initialization.

==== Conventions for Metamodel Fields

The following are conventions for static metamodel classes:

- The name of the static metamodel class should consist of underscore (`_`) followed by the entity class name.
- Fields of type `String` should be named with all upper case.
- Fields of type `Attribute` (or a subinterface of `Attribute`) should be named in lower case or mixed case.
- Uninitialized fields should have modifiers `public`, `static`, and `volatile`.
- Initialized fields must have modifiers `public`, `static`, and `final`.
- Fields of type `String` must always be statically initialized, enabling their use in annotation values.

==== Example Metamodel Class and Usage

Example entity class:

[source,java]
----
@Entity
public class Product {
  public long id;
  public String name;
  public float price;
}
----

Example metamodel class for the entity:

[source,java]
----
@StaticMetamodel(Product.class)
public class _Product {
  public static final String ID = "id";
  public static final String NAME = "name";
  public static final String PRICE = "price";

  public static final SortableAttribute<Product> id = new SortableAttributeRecord<>("id");
  public static final TextAttribute<Product> name = new TextAttributeRecord<>("name");
  public static final SortableAttribute<Product> price = new SortableAttributeRecord<>("price");
}
----

Example usage:

[source,java]
----
List<Product> found = products.findByNameLike(searchPattern,
                                              _Product.price.desc(),
                                              _Product.name.asc(),
                                              _Product.id.asc());
----
